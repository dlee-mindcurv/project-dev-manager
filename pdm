#!/bin/bash

# PDM - Project Dev Manager
# Global CLI tool for autonomous feature development
# Installs skills and commands to project's .claude/ folder with pdm- prefixes

set -e

VERSION="1.0.0"

# Find project root (git root or current directory)
find_git_root() {
    git rev-parse --show-toplevel 2>/dev/null || echo "$PWD"
}

PROJECT_ROOT="$(find_git_root)"
CLAUDE_DIR="$PROJECT_ROOT/.claude"
SKILLS_DIR="$CLAUDE_DIR/skills"
COMMANDS_DIR="$CLAUDE_DIR/commands"
PDM_REPO="dlee-mindcurv/pdm-tools"
RAW_BASE="https://raw.githubusercontent.com/$PDM_REPO/main"
ARCHIVE_URL="https://github.com/$PDM_REPO/archive/refs/heads/main.tar.gz"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Print usage
usage() {
    echo ""
    echo -e "${BLUE}PDM - Project Dev Manager${NC} v${VERSION}"
    echo ""
    echo "Usage: pdm <command> [options]"
    echo ""
    echo -e "${CYAN}Installation Commands:${NC}"
    echo "  --install [type]     Install skills and commands to project's .claude/"
    echo "                       type: 'skills', 'commands', or omit for all"
    echo "  --update             Force re-download everything"
    echo "  --uninstall          Remove all pdm-* skills and commands"
    echo ""
    echo -e "${CYAN}Info Commands:${NC}"
    echo "  --list               Show installed pdm-* items"
    echo "  --check              Verify dependencies (Claude CLI, Node, Git, curl)"
    echo ""
    echo -e "${CYAN}Feature Lifecycle:${NC}"
    echo "  --draft-feature [name]     Create a new feature (interactive if no name given)"
    echo "  --build-feature, -f <id>   Run Ralph on feature"
    echo "  --max-iterations <n>  Max iterations for feature execution (default: 10)"
    echo ""
    echo -e "${CYAN}Workspace Commands:${NC}"
    echo "  --create-workspace <id>    Create isolated git worktree for a feature"
    echo "  --list-workspaces          Show all workspaces with status"
    echo "  --complete-feature <id>    Push branch and create PR to main"
    echo "  --cleanup-workspace <id>   Remove worktree after PR merge"
    echo ""
    echo -e "${CYAN}Meta:${NC}"
    echo "  --version, -v        Show version"
    echo "  --help, -h           Show this help message"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  pdm --install              # Install all skills and commands"
    echo "  pdm --install skills       # Install only skills"
    echo "  pdm --list                 # Show installed items"
    echo "  pdm --draft-feature                # Interactive feature creation"
    echo "  pdm --draft-feature \"Dark Mode\"    # Create feature with name directly"
    echo "  pdm -f my-feature          # Execute Ralph on 'my-feature' feature"
    echo "  pdm -f my-feature --max-iterations 20"
    echo ""
}

# JSON helper using Node.js (eliminates jq dependency)
json_get() {
    local file="$1"
    local path="$2"
    node -e "console.log(JSON.parse(require('fs').readFileSync('$file','utf8'))$path || '')" 2>/dev/null
}

json_array_length() {
    local file="$1"
    local path="$2"
    node -e "console.log(JSON.parse(require('fs').readFileSync('$file','utf8'))$path.length)" 2>/dev/null
}

json_array_item() {
    local file="$1"
    local path="$2"
    local index="$3"
    local prop="$4"
    node -e "console.log(JSON.parse(require('fs').readFileSync('$file','utf8'))$path[$index].$prop || '')" 2>/dev/null
}

# Generate feature ID from name (e.g., "My Feature" -> "my-feature")
generate_feature_id() {
    local name="$1"
    echo "$name" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-'
}

# Update status.json with a new feature entry (uses Node.js, no jq dependency)
update_status_json() {
    local status_file="$1"
    local id="$2"
    local name="$3"
    local status="${4:-OPEN}"
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')

    # Create status.json if it doesn't exist
    if [[ ! -f "$status_file" ]]; then
        echo '{ "features": [] }' > "$status_file"
    fi

    node -e "
        const fs = require('fs');
        const file = process.argv[1];
        const id = process.argv[2];
        const name = process.argv[3];
        const status = process.argv[4];
        const ts = process.argv[5];
        const data = JSON.parse(fs.readFileSync(file, 'utf8'));
        if (data.features.some(f => f.id === id)) {
            console.log('Feature ' + id + ' already exists in status.json');
            process.exit(0);
        }
        data.features.push({ id, name, status, createdAt: ts, updatedAt: ts });
        fs.writeFileSync(file, JSON.stringify(data, null, 2) + '\n');
    " "$status_file" "$id" "$name" "$status" "$timestamp"
}

format_elapsed() {
    local total_seconds="$1"
    local hours=$((total_seconds / 3600))
    local minutes=$(( (total_seconds % 3600) / 60 ))
    local seconds=$((total_seconds % 60))
    if [[ $hours -gt 0 ]]; then
        printf "%dh %dm %ds" "$hours" "$minutes" "$seconds"
    elif [[ $minutes -gt 0 ]]; then
        printf "%dm %ds" "$minutes" "$seconds"
    else
        printf "%ds" "$seconds"
    fi
}

# ============================================================================
# WORKSPACE HELPERS
# ============================================================================

# Returns path to the workspace tracking file
workspace_tracking_file() {
    echo "$PROJECT_ROOT/.pdm-workspaces/workspaces.json"
}

# Creates the workspace directory and empty tracking JSON if missing
init_workspace_tracking() {
    local ws_dir="$PROJECT_ROOT/.pdm-workspaces"
    local ws_file="$ws_dir/workspaces.json"

    mkdir -p "$ws_dir"

    if [[ ! -f "$ws_file" ]]; then
        echo '{ "workspaces": [] }' > "$ws_file"
    fi
}

# Returns the worktree path for an active workspace, or empty string if not found
get_workspace_path() {
    local feature_id="$1"
    local ws_file
    ws_file="$(workspace_tracking_file)"

    if [[ ! -f "$ws_file" ]]; then
        echo ""
        return
    fi

    node -e "
        const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8'));
        const ws = data.workspaces.find(w => w.featureId === process.argv[2] && w.status === 'active');
        console.log(ws ? ws.worktreePath : '');
    " "$ws_file" "$feature_id"
}

# Upserts a workspace entry in tracking JSON
update_workspace_tracking() {
    local feature_id="$1"
    local branch="$2"
    local ws_path="$3"
    local status="$4"
    local pr_url="${5:-}"

    init_workspace_tracking

    local ws_file
    ws_file="$(workspace_tracking_file)"
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')

    node -e "
        const fs = require('fs');
        const file = process.argv[1];
        const featureId = process.argv[2];
        const branch = process.argv[3];
        const wsPath = process.argv[4];
        const status = process.argv[5];
        const ts = process.argv[6];
        const prUrl = process.argv[7] || null;
        const data = JSON.parse(fs.readFileSync(file, 'utf8'));
        const idx = data.workspaces.findIndex(w => w.featureId === featureId);
        if (idx >= 0) {
            data.workspaces[idx].status = status;
            data.workspaces[idx].lastBuildAt = ts;
            if (prUrl) data.workspaces[idx].prUrl = prUrl;
        } else {
            data.workspaces.push({
                featureId,
                branch,
                worktreePath: wsPath,
                status,
                createdAt: ts,
                lastBuildAt: null,
                prUrl: null
            });
        }
        fs.writeFileSync(file, JSON.stringify(data, null, 2) + '\n');
    " "$ws_file" "$feature_id" "$branch" "$ws_path" "$status" "$timestamp" "$pr_url"
}

# Create JTBD template if it doesn't exist
setup_jtbd_template() {
    local resources_dir="$1"
    local template_file="$resources_dir/JTBD-template.md"

    mkdir -p "$resources_dir"

    if [[ -f "$template_file" ]]; then
        return 0
    fi

    cat > "$template_file" << 'JTBD_EOF'
# Jobs-to-be-Done Analysis: [FEATURE_NAME]

## Feature Summary

[Brief description of the feature]

---

## Job Statements

### Primary Job

**When** [situation], **I want** [motivation], **so I can** [expected outcome].

### Secondary Jobs

1. **When** [situation], **I want** [motivation], **so I can** [expected outcome].

---

## User Needs and Pain Points

### Needs

| Need | Description |
|------|-------------|
| [Need] | [Description] |

### Pain Points Addressed

| Pain Point | How This Feature Helps |
|------------|----------------------|
| [Pain Point] | [How it helps] |

---

## Desired Outcomes (User Perspective)

### Functional Outcomes

- [Outcome]

### Emotional Outcomes

- [Outcome]

### Social Outcomes

- [Outcome]

---

## Competitive Analysis (JTBD Lens)

| Competitor | How They Solve This Job |
|------------|------------------------|
| [Competitor] | [Their approach] |

### Competitive Insight

[Analysis of competitive landscape]

---

## Market Opportunity Assessment

### Brand Differentiation

- [Differentiation point]

### User Expectations

[What users expect]

### Strategic Value

| Factor | Impact |
|--------|--------|
| [Factor] | [Impact] |

---

## Success Criteria (From User Perspective)

- [Success criterion]

---

## Assumptions to Validate

1. [Assumption to validate]
JTBD_EOF
    echo -e "${GREEN}✓ Created JTBD template: $template_file${NC}"
}

# Create PRD template if it doesn't exist
setup_prd_template() {
    local resources_dir="$1"
    local template_file="$resources_dir/PRD-template.md"

    mkdir -p "$resources_dir"

    if [[ -f "$template_file" ]]; then
        return 0
    fi

    cat > "$template_file" << 'PRD_EOF'
# PRD: [FEATURE_NAME]

## Introduction

[Brief description of the feature and the problem it solves.]

## Goals

- [Specific, measurable objective]
- [Another objective]

## User Stories

### US-001: [Title]
**Description:** As a [user], I want [feature] so that [benefit].

**Acceptance Criteria:**
- [ ] Specific verifiable criterion
- [ ] Another criterion
- [ ] Tests pass/jest coverage is 80%
- [ ] Typecheck/lint passes

### US-002: [Title]
**Description:** As a [user], I want [feature] so that [benefit].

**Acceptance Criteria:**
- [ ] Specific verifiable criterion
- [ ] Typecheck/lint passes
- [ ] Tests pass/jest coverage is 80%
- [ ] Verify in browser using pdm-webapp-testing skill

## Functional Requirements

- FR-1: The system must [specific functionality]
- FR-2: When a user [action], the system must [response]

## Non-Goals

- [What this feature will NOT include]
- [Another exclusion]

## Design Considerations

- [UI/UX requirements]
- [Relevant existing components to reuse]

## Technical Considerations

- [Known constraints or dependencies]
- [Integration points with existing systems]

## Success Metrics

- [How success will be measured]
- [Another metric]

## Open Questions

- [Remaining questions or areas needing clarification]
PRD_EOF
    echo -e "${GREEN}✓ Created PRD template: $template_file${NC}"
}

# Check dependencies
cmd_check() {
    echo ""
    echo -e "${BLUE}Checking PDM dependencies...${NC}"
    echo ""

    local all_ok=true

    # Claude CLI
    if command -v claude &> /dev/null; then
        local claude_version=$(claude --version 2>&1 | head -1 || echo "unknown")
        echo -e "${GREEN}✓${NC} Claude CLI: $claude_version"
    else
        echo -e "${RED}✗${NC} Claude CLI: not found"
        echo "  Install from: https://github.com/anthropics/claude-code"
        all_ok=false
    fi

    # Node.js
    if command -v node &> /dev/null; then
        local node_version=$(node --version)
        echo -e "${GREEN}✓${NC} Node.js: $node_version"

        # Check version >= 18
        local major_version=$(echo "$node_version" | sed 's/v//' | cut -d. -f1)
        if [[ "$major_version" -lt 18 ]]; then
            echo -e "  ${YELLOW}Warning: Node.js 18+ recommended${NC}"
        fi
    else
        echo -e "${RED}✗${NC} Node.js: not found"
        all_ok=false
    fi

    # Git
    if command -v git &> /dev/null; then
        local git_version=$(git --version | sed 's/git version //')
        echo -e "${GREEN}✓${NC} Git: $git_version"
    else
        echo -e "${RED}✗${NC} Git: not found"
        all_ok=false
    fi

    # curl
    if command -v curl &> /dev/null; then
        local curl_version=$(curl --version | head -1 | awk '{print $2}')
        echo -e "${GREEN}✓${NC} curl: $curl_version"
    else
        echo -e "${RED}✗${NC} curl: not found"
        all_ok=false
    fi

    # Bash
    echo -e "${GREEN}✓${NC} Bash: $BASH_VERSION"

    echo ""
    if $all_ok; then
        echo -e "${GREEN}All dependencies satisfied!${NC}"
    else
        echo -e "${RED}Some dependencies are missing. Please install them.${NC}"
        exit 1
    fi
}

# List installed pdm-* items
cmd_list() {
    echo ""
    echo -e "${BLUE}Installed PDM items${NC}"
    echo ""

    echo -e "${CYAN}Skills:${NC} ($SKILLS_DIR)"
    if [[ -d "$SKILLS_DIR" ]]; then
        local skills=$(ls -1 "$SKILLS_DIR" 2>/dev/null | grep "^pdm-" || true)
        if [[ -n "$skills" ]]; then
            echo "$skills" | while read skill; do
                echo "  • $skill"
            done
        else
            echo "  (none)"
        fi
    else
        echo "  (directory does not exist)"
    fi

    echo ""
    echo -e "${CYAN}Commands:${NC} ($COMMANDS_DIR)"
    if [[ -d "$COMMANDS_DIR" ]]; then
        local commands=$(ls -1 "$COMMANDS_DIR" 2>/dev/null | grep "^pdm-" || true)
        if [[ -n "$commands" ]]; then
            echo "$commands" | while read cmd; do
                echo "  • /${cmd%.md}"
            done
        else
            echo "  (none)"
        fi
    else
        echo "  (directory does not exist)"
    fi
    echo ""
}

# Install skills and/or commands
cmd_install() {
    local install_type="${1:-all}"  # skills, commands, or all

    echo ""
    echo -e "${BLUE}Installing PDM tools to $CLAUDE_DIR...${NC}"
    echo ""

    # Create directories
    mkdir -p "$SKILLS_DIR" "$COMMANDS_DIR"

    # Create temp directory for download
    local tmp_dir=$(mktemp -d)
    local archive_file="$tmp_dir/pdm-tools.tar.gz"
    local extract_dir="$tmp_dir/extracted"

    # Download archive
    echo -e "${CYAN}Downloading from $PDM_REPO...${NC}"
    if ! curl -sL "$ARCHIVE_URL" -o "$archive_file"; then
        echo -e "${RED}Error: Failed to download from GitHub${NC}"
        rm -rf "$tmp_dir"
        exit 1
    fi

    # Extract archive
    mkdir -p "$extract_dir"
    tar -xzf "$archive_file" -C "$extract_dir"

    # Find extracted directory (usually pdm-tools-main)
    local src_dir=$(find "$extract_dir" -maxdepth 1 -type d -name "pdm-tools-*" | head -1)

    if [[ -z "$src_dir" || ! -d "$src_dir" ]]; then
        echo -e "${RED}Error: Could not find extracted content${NC}"
        rm -rf "$tmp_dir"
        exit 1
    fi

    # Install skills
    if [[ "$install_type" == "all" || "$install_type" == "skills" ]]; then
        if [[ -d "$src_dir/skills" ]]; then
            echo ""
            echo -e "${CYAN}Installing skills...${NC}"
            for skill_dir in "$src_dir/skills"/pdm-*; do
                if [[ -d "$skill_dir" ]]; then
                    local skill_name=$(basename "$skill_dir")
                    echo "  • $skill_name"
                    rm -rf "$SKILLS_DIR/$skill_name"
                    cp -r "$skill_dir" "$SKILLS_DIR/"
                fi
            done
        else
            echo -e "${YELLOW}No skills directory found in repository${NC}"
        fi
    fi

    # Install commands
    if [[ "$install_type" == "all" || "$install_type" == "commands" ]]; then
        if [[ -d "$src_dir/commands" ]]; then
            echo ""
            echo -e "${CYAN}Installing commands...${NC}"
            for cmd_file in "$src_dir/commands"/pdm-*.md; do
                if [[ -f "$cmd_file" ]]; then
                    local cmd_name=$(basename "$cmd_file")
                    echo "  • /${cmd_name%.md}"
                    cp "$cmd_file" "$COMMANDS_DIR/"
                fi
            done
        else
            echo -e "${YELLOW}No commands directory found in repository${NC}"
        fi
    fi

    # Cleanup
    rm -rf "$tmp_dir"

    echo ""
    echo -e "${GREEN}✓ Installation complete!${NC}"
    echo ""
    echo "Run 'pdm --list' to see installed items."
    echo ""
}

# Update (force re-download)
cmd_update() {
    echo -e "${BLUE}Updating PDM tools...${NC}"
    cmd_uninstall
    cmd_install all
}

# Uninstall pdm-* items
cmd_uninstall() {
    echo ""
    echo -e "${BLUE}Removing PDM skills and commands...${NC}"
    echo ""

    # Remove skills
    if [[ -d "$SKILLS_DIR" ]]; then
        local skills=$(ls -1 "$SKILLS_DIR" 2>/dev/null | grep "^pdm-" || true)
        if [[ -n "$skills" ]]; then
            echo -e "${CYAN}Removing skills:${NC}"
            echo "$skills" | while read skill; do
                echo "  • $skill"
                rm -rf "$SKILLS_DIR/$skill"
            done
        fi
    fi

    # Remove commands
    if [[ -d "$COMMANDS_DIR" ]]; then
        local commands=$(ls -1 "$COMMANDS_DIR" 2>/dev/null | grep "^pdm-" || true)
        if [[ -n "$commands" ]]; then
            echo -e "${CYAN}Removing commands:${NC}"
            echo "$commands" | while read cmd; do
                echo "  • $cmd"
                rm -f "$COMMANDS_DIR/$cmd"
            done
        fi
    fi

    echo ""
    echo -e "${GREEN}✓ Uninstall complete!${NC}"
    echo ""
}

# ============================================================================
# FEATURE CREATION
# ============================================================================

# Create a new feature (interactive or direct)
cmd_draft_feature() {
    local feature_name="$1"

    echo ""
    echo -e "${BLUE}╔═══════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║     Feature Creation                  ║${NC}"
    echo -e "${BLUE}╚═══════════════════════════════════════╝${NC}"
    echo ""

    # Find project root (or use current directory)
    local project_root
    if project_root=$(find_project_root); then
        echo -e "${GREEN}✓ Found project root: $project_root${NC}"
    else
        project_root="$PWD"
        echo -e "${YELLOW}No existing product-development directory found.${NC}"
        echo -e "${YELLOW}Using current directory: $project_root${NC}"
    fi

    local features_dir="$project_root/product-development/features"
    local resources_dir="$project_root/product-development/resources"
    local status_json="$features_dir/status.json"
    local product_md="$project_root/product.md"

    # Create directories
    mkdir -p "$features_dir" "$resources_dir"

    # Copy product.md to resources if it exists
    if [[ -f "$product_md" ]]; then
        cp "$product_md" "$resources_dir/product.md"
        echo -e "${GREEN}✓ Copied product.md to resources directory${NC}"
    fi

    # Setup templates
    setup_jtbd_template "$resources_dir"
    setup_prd_template "$resources_dir"

    # Check for Claude CLI
    if ! command -v claude &> /dev/null; then
        echo -e "${RED}Error: Claude CLI not found.${NC}"
        echo -e "Please install Claude Code and try again."
        exit 1
    fi

    # Ensure PDM skills are installed
    local command_file="$COMMANDS_DIR/pdm-create-jtbd.md"
    if [[ -f "$command_file" ]]; then
        echo -e "${GREEN}✓ PDM skills already installed${NC}"
    else
        echo -e "${YELLOW}PDM skills not found. Installing via pdm --install...${NC}"
        cmd_install
    fi

    echo ""

    # Feature ID will be set during input collection
    local feature_id=""

    if [[ -n "$feature_name" ]]; then
        # Direct mode: name provided via flag
        feature_id=$(generate_feature_id "$feature_name")
        echo -e "${BLUE}Feature name: $feature_name${NC}"
        echo -e "${BLUE}Generated feature ID: $feature_id${NC}"

        echo ""
        echo "Feature description (press Enter twice when done):"
        echo ""

        local feature_description=""
        while IFS= read -r line; do
            [[ -z "$line" ]] && break
            feature_description+="$line"$'\n'
        done
        feature_description="${feature_description%$'\n'}"

        if [[ -z "$feature_description" ]]; then
            echo -e "${RED}Error: Feature description cannot be empty${NC}"
            exit 1
        fi

        # Create feature directory and file
        local feature_dir="$features_dir/$feature_id"
        mkdir -p "$feature_dir"
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        cat > "$feature_dir/feature.md" << FEAT_EOF
# Feature: $feature_name

## Description

$feature_description

## Status

- Created: $timestamp
- Status: Draft
FEAT_EOF

        echo -e "${GREEN}✓ Created feature file: $feature_dir/feature.md${NC}"
        update_status_json "$status_json" "$feature_id" "$feature_name" "OPEN"
        echo -e "${GREEN}✓ Updated status.json with feature: $feature_id${NC}"

    else
        # Interactive mode: show menu
        echo -e "${YELLOW}Create a new feature:${NC}"
        echo ""
        echo -e "${BLUE}How would you like to provide the feature details?${NC}"
        echo ""
        echo "  1) Enter feature name and description manually"
        echo "  2) Reference an existing feature file"
        echo "  3) Cancel"
        echo ""
        read -p "Select an option [1-3]: " choice

        case $choice in
            1)
                echo ""
                echo -e "${BLUE}Enter feature details:${NC}"
                echo ""

                read -p "Feature name: " feature_name
                if [[ -z "$feature_name" ]]; then
                    echo -e "${RED}Error: Feature name cannot be empty${NC}"
                    exit 1
                fi

                feature_id=$(generate_feature_id "$feature_name")
                echo -e "${BLUE}Generated feature ID: $feature_id${NC}"

                echo ""
                echo "Feature description (press Enter twice when done):"
                echo ""

                local feature_description=""
                while IFS= read -r line; do
                    [[ -z "$line" ]] && break
                    feature_description+="$line"$'\n'
                done
                feature_description="${feature_description%$'\n'}"

                if [[ -z "$feature_description" ]]; then
                    echo -e "${RED}Error: Feature description cannot be empty${NC}"
                    exit 1
                fi

                # Create feature directory and file
                local feature_dir="$features_dir/$feature_id"
                mkdir -p "$feature_dir"
                local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
                cat > "$feature_dir/feature.md" << FEAT_EOF
# Feature: $feature_name

## Description

$feature_description

## Status

- Created: $timestamp
- Status: Draft
FEAT_EOF

                echo ""
                echo -e "${GREEN}✓ Created feature file: $feature_dir/feature.md${NC}"
                update_status_json "$status_json" "$feature_id" "$feature_name" "OPEN"
                echo -e "${GREEN}✓ Updated status.json with feature: $feature_id${NC}"
                ;;
            2)
                echo ""
                read -p "Enter the path to the existing feature file: " file_path
                file_path="${file_path/#\~/$HOME}"

                if [[ ! -f "$file_path" ]]; then
                    echo -e "${RED}Error: File not found: $file_path${NC}"
                    exit 1
                fi

                echo ""
                read -p "Enter a name for this feature (used to generate ID): " feature_name
                if [[ -z "$feature_name" ]]; then
                    echo -e "${RED}Error: Feature name cannot be empty${NC}"
                    exit 1
                fi

                feature_id=$(generate_feature_id "$feature_name")
                local feature_dir="$features_dir/$feature_id"
                mkdir -p "$feature_dir"
                cp "$file_path" "$feature_dir/feature.md"
                echo -e "${GREEN}✓ Copied feature file to: $feature_dir/feature.md${NC}"
                update_status_json "$status_json" "$feature_id" "$feature_name" "OPEN"
                echo -e "${GREEN}✓ Updated status.json with feature: $feature_id${NC}"
                ;;
            3)
                echo -e "${YELLOW}Cancelled.${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Invalid option. Exiting.${NC}"
                exit 1
                ;;
        esac
    fi

    echo ""
    echo -e "${BLUE}Launching Claude Code with /pdm-create-jtbd ${feature_id}...${NC}"
    echo ""

    cd "$project_root"
    claude "/pdm-create-jtbd ${feature_id}"
}

# ============================================================================
# WORKSPACE COMMANDS
# ============================================================================

# Create an isolated git worktree workspace for a feature
cmd_create_workspace() {
    local feature_id="$1"

    if [[ -z "$feature_id" ]]; then
        echo -e "${RED}Error: Feature ID required${NC}"
        echo "Usage: pdm --create-workspace <feature-id>"
        exit 1
    fi

    # Find project root
    local project_root
    if ! project_root=$(find_project_root); then
        echo -e "${RED}Error: Could not find project with product-development/features directory${NC}"
        exit 1
    fi

    local features_dir="$project_root/product-development/features"
    local feature_dir="$features_dir/$feature_id"
    local prd_json="$feature_dir/prd.json"

    # Validate feature directory
    if [[ ! -d "$feature_dir" ]]; then
        echo -e "${RED}Error: Feature directory not found: $feature_dir${NC}"
        exit 1
    fi

    # Validate prd.json
    if [[ ! -f "$prd_json" ]]; then
        echo -e "${RED}Error: prd.json not found: $prd_json${NC}"
        echo -e "${YELLOW}Run /pdm-create-prd-json $feature_id first to generate prd.json${NC}"
        exit 1
    fi

    # Read branch name from prd.json
    local branch
    branch=$(json_get "$prd_json" ".branchName")
    if [[ -z "$branch" ]]; then
        echo -e "${RED}Error: branchName not found in prd.json${NC}"
        exit 1
    fi

    local ws_dir="$project_root/.pdm-workspaces"
    local ws_path="$ws_dir/$feature_id"

    # Check workspace doesn't already exist
    local existing_path
    existing_path=$(get_workspace_path "$feature_id")
    if [[ -n "$existing_path" ]]; then
        echo -e "${RED}Error: Workspace already exists for feature '$feature_id'${NC}"
        echo -e "${YELLOW}Run 'pdm --cleanup-workspace $feature_id' first${NC}"
        exit 1
    fi

    # Check branch doesn't already exist
    if git -C "$project_root" rev-parse --verify "$branch" &>/dev/null; then
        echo -e "${RED}Error: Branch '$branch' already exists${NC}"
        echo -e "${YELLOW}Delete the branch or change branchName in prd.json${NC}"
        exit 1
    fi

    echo ""
    echo -e "${BLUE}Creating workspace for feature: $feature_id${NC}"
    echo -e "${BLUE}Branch: $branch${NC}"
    echo ""

    # Stash uncommitted changes if present
    local stashed=false
    if ! git -C "$project_root" diff --quiet HEAD 2>/dev/null || \
       ! git -C "$project_root" diff --cached --quiet HEAD 2>/dev/null; then
        echo -e "${YELLOW}Stashing uncommitted changes...${NC}"
        git -C "$project_root" stash push -m "pdm-workspace-create-$feature_id" 2>/dev/null && stashed=true
    fi

    # Create worktree
    mkdir -p "$ws_dir"
    echo -e "${CYAN}Creating git worktree...${NC}"
    if ! git -C "$project_root" worktree add "$ws_path" -b "$branch" main 2>&1; then
        echo -e "${RED}Error: Failed to create git worktree${NC}"
        if [[ "$stashed" == "true" ]]; then
            git -C "$project_root" stash pop 2>/dev/null || true
        fi
        exit 1
    fi

    # Copy gitignored content into worktree
    echo -e "${CYAN}Copying feature configuration...${NC}"

    # product-development/features/<id>/
    mkdir -p "$ws_path/product-development/features"
    cp -r "$feature_dir" "$ws_path/product-development/features/"

    # product-development/features/status.json
    local status_json="$features_dir/status.json"
    if [[ -f "$status_json" ]]; then
        cp "$status_json" "$ws_path/product-development/features/"
    fi

    # product-development/resources/
    local resources_dir="$project_root/product-development/resources"
    if [[ -d "$resources_dir" ]]; then
        mkdir -p "$ws_path/product-development"
        cp -r "$resources_dir" "$ws_path/product-development/"
    fi

    # .claude/ directory
    local claude_dir="$project_root/.claude"
    if [[ -d "$claude_dir" ]]; then
        cp -r "$claude_dir" "$ws_path/"
    fi

    # LEARNINGS.md
    if [[ -f "$project_root/LEARNINGS.md" ]]; then
        cp "$project_root/LEARNINGS.md" "$ws_path/"
    fi

    # CLAUDE.md
    if [[ -f "$project_root/CLAUDE.md" ]]; then
        cp "$project_root/CLAUDE.md" "$ws_path/"
    fi

    # Run npm install for subdirectories with package.json
    echo -e "${CYAN}Installing dependencies...${NC}"
    for pkg_json in "$ws_path"/*/package.json; do
        if [[ -f "$pkg_json" ]]; then
            local pkg_dir=$(dirname "$pkg_json")
            local pkg_name=$(basename "$pkg_dir")
            echo -e "  Installing in $pkg_name/..."
            (cd "$pkg_dir" && npm install 2>&1) || echo -e "${YELLOW}  Warning: npm install failed in $pkg_name/${NC}"
        fi
    done

    # Record in tracking
    update_workspace_tracking "$feature_id" "$branch" "$ws_path" "active"

    # Pop stash if needed
    if [[ "$stashed" == "true" ]]; then
        echo -e "${CYAN}Restoring stashed changes...${NC}"
        git -C "$project_root" stash pop 2>/dev/null || true
    fi

    echo ""
    echo -e "${GREEN}✓ Workspace created: $ws_path${NC}"
    echo -e "${GREEN}✓ Branch: $branch${NC}"
    echo ""
    echo -e "Run 'pdm --build-feature $feature_id' to start building."
    echo ""
}

# List all workspaces with status
cmd_list_workspaces() {
    local project_root
    if ! project_root=$(find_project_root); then
        echo -e "${RED}Error: Could not find project with product-development/features directory${NC}"
        exit 1
    fi

    local ws_file
    ws_file="$(workspace_tracking_file)"

    if [[ ! -f "$ws_file" ]]; then
        echo ""
        echo -e "${YELLOW}No workspaces found.${NC}"
        echo "Create one with: pdm --create-workspace <feature-id>"
        echo ""
        return
    fi

    local count
    count=$(node -e "
        const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8'));
        console.log(data.workspaces.length);
    " "$ws_file")

    if [[ "$count" -eq 0 ]]; then
        echo ""
        echo -e "${YELLOW}No workspaces found.${NC}"
        echo "Create one with: pdm --create-workspace <feature-id>"
        echo ""
        return
    fi

    echo ""
    echo -e "${BLUE}PDM Workspaces${NC}"
    echo ""
    printf "%-20s %-30s %-12s %-40s %s\n" "FEATURE" "BRANCH" "STATUS" "PATH" "PR"
    printf "%-20s %-30s %-12s %-40s %s\n" "-------" "------" "------" "----" "--"

    node -e "
        const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8'));
        data.workspaces.forEach(w => {
            const pr = w.prUrl || '-';
            console.log([w.featureId, w.branch, w.status, w.worktreePath, pr].join('|'));
        });
    " "$ws_file" | while IFS='|' read -r fid branch status path pr; do
        printf "%-20s %-30s %-12s %-40s %s\n" "$fid" "$branch" "$status" "$path" "$pr"
    done

    echo ""
}

# Push branch and create PR for a completed feature
cmd_complete_feature() {
    local feature_id="$1"

    if [[ -z "$feature_id" ]]; then
        echo -e "${RED}Error: Feature ID required${NC}"
        echo "Usage: pdm --complete-feature <feature-id>"
        exit 1
    fi

    # Find project root
    local project_root
    if ! project_root=$(find_project_root); then
        echo -e "${RED}Error: Could not find project with product-development/features directory${NC}"
        exit 1
    fi

    # Look up workspace
    local ws_path
    ws_path=$(get_workspace_path "$feature_id")
    if [[ -z "$ws_path" ]]; then
        echo -e "${RED}Error: No active workspace found for feature '$feature_id'${NC}"
        exit 1
    fi

    local prd_json="$ws_path/product-development/features/$feature_id/prd.json"
    local progress_file="$ws_path/product-development/features/$feature_id/progress.txt"

    if [[ ! -f "$prd_json" ]]; then
        echo -e "${RED}Error: prd.json not found in workspace${NC}"
        exit 1
    fi

    # Check if gh CLI is available
    if ! command -v gh &> /dev/null; then
        echo -e "${RED}Error: GitHub CLI (gh) not found${NC}"
        echo "Install from: https://cli.github.com/"
        exit 1
    fi

    # Check story completion status
    local incomplete_count
    incomplete_count=$(node -e "
        const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8'));
        console.log(data.userStories.filter(s => !s.passes).length);
    " "$prd_json")

    if [[ "$incomplete_count" -gt 0 ]]; then
        echo -e "${YELLOW}Warning: $incomplete_count stories are still incomplete${NC}"
        read -p "Continue anyway? [y/N] " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo -e "${YELLOW}Cancelled.${NC}"
            exit 0
        fi
    fi

    # Read branch and feature info
    local branch
    branch=$(json_get "$prd_json" ".branchName")
    local feature_name
    feature_name=$(json_get "$prd_json" ".featureName")
    local feature_desc
    feature_desc=$(json_get "$prd_json" ".description")

    echo ""
    echo -e "${BLUE}Completing feature: $feature_id${NC}"
    echo ""

    # Push branch
    echo -e "${CYAN}Pushing branch '$branch' to origin...${NC}"
    if ! git -C "$ws_path" push -u origin "$branch" 2>&1; then
        echo -e "${RED}Error: Failed to push branch${NC}"
        exit 1
    fi

    # Build PR body with story checklist
    local story_checklist
    story_checklist=$(node -e "
        const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8'));
        data.userStories.forEach(s => {
            const check = s.passes ? 'x' : ' ';
            console.log('- [' + check + '] ' + s.id + ': ' + s.title);
        });
    " "$prd_json")

    local pr_title="feat: $feature_name"
    # Truncate title to 70 chars
    if [[ ${#pr_title} -gt 70 ]]; then
        pr_title="${pr_title:0:67}..."
    fi

    echo -e "${CYAN}Creating pull request...${NC}"
    local pr_url
    pr_url=$(cd "$ws_path" && gh pr create --base main --head "$branch" \
        --title "$pr_title" \
        --body "$(cat <<EOF
## Summary

$feature_desc

## Stories

$story_checklist

## Feature

ID: \`$feature_id\`
Branch: \`$branch\`
EOF
    )" 2>&1)

    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Error creating PR: $pr_url${NC}"
        exit 1
    fi

    echo -e "${GREEN}✓ Pull request created: $pr_url${NC}"

    # Sync prd.json and progress.txt back to main's product-development/
    local main_feature_dir="$project_root/product-development/features/$feature_id"
    mkdir -p "$main_feature_dir"
    cp "$prd_json" "$main_feature_dir/"
    if [[ -f "$progress_file" ]]; then
        cp "$progress_file" "$main_feature_dir/"
    fi
    echo -e "${GREEN}✓ Synced progress files back to main${NC}"

    # Update tracking
    update_workspace_tracking "$feature_id" "$branch" "$ws_path" "completed" "$pr_url"

    echo ""
    echo -e "${GREEN}✓ Feature '$feature_id' completed!${NC}"
    echo -e "PR: $pr_url"
    echo ""
    echo -e "After PR is merged, run: pdm --cleanup-workspace $feature_id"
    echo ""
}

# Remove a workspace worktree and clean up
cmd_cleanup_workspace() {
    local feature_id="$1"
    local force_flag="${2:-}"

    if [[ -z "$feature_id" ]]; then
        echo -e "${RED}Error: Feature ID required${NC}"
        echo "Usage: pdm --cleanup-workspace <feature-id>"
        exit 1
    fi

    # Find project root
    local project_root
    if ! project_root=$(find_project_root); then
        echo -e "${RED}Error: Could not find project with product-development/features directory${NC}"
        exit 1
    fi

    # Look up workspace path from tracking
    local ws_file
    ws_file="$(workspace_tracking_file)"
    local ws_path=""

    if [[ -f "$ws_file" ]]; then
        ws_path=$(node -e "
            const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8'));
            const ws = data.workspaces.find(w => w.featureId === process.argv[2] && w.status !== 'removed');
            console.log(ws ? ws.worktreePath : '');
        " "$ws_file" "$feature_id")
    fi

    if [[ -z "$ws_path" ]]; then
        echo -e "${RED}Error: No active or completed workspace found for feature '$feature_id'${NC}"
        exit 1
    fi

    echo ""
    echo -e "${BLUE}Cleaning up workspace for feature: $feature_id${NC}"
    echo ""

    # Sync progress files back to main before removal
    local main_feature_dir="$project_root/product-development/features/$feature_id"
    local ws_feature_dir="$ws_path/product-development/features/$feature_id"
    if [[ -d "$ws_feature_dir" ]]; then
        mkdir -p "$main_feature_dir"
        for file in prd.json progress.txt; do
            if [[ -f "$ws_feature_dir/$file" ]]; then
                cp "$ws_feature_dir/$file" "$main_feature_dir/"
            fi
        done
        echo -e "${GREEN}✓ Synced progress files back to main${NC}"
    fi

    # Remove worktree
    echo -e "${CYAN}Removing worktree...${NC}"
    local remove_args=""
    if [[ "$force_flag" == "--force" ]]; then
        remove_args="--force"
    fi

    if ! git -C "$project_root" worktree remove "$ws_path" $remove_args 2>&1; then
        echo -e "${RED}Error: Failed to remove worktree${NC}"
        echo -e "${YELLOW}Try: pdm --cleanup-workspace $feature_id --force${NC}"
        exit 1
    fi

    # Prune worktrees
    git -C "$project_root" worktree prune 2>/dev/null || true

    # Update tracking
    local branch
    branch=$(node -e "
        const data = JSON.parse(require('fs').readFileSync(process.argv[1], 'utf8'));
        const ws = data.workspaces.find(w => w.featureId === process.argv[2]);
        console.log(ws ? ws.branch : '');
    " "$ws_file" "$feature_id")

    update_workspace_tracking "$feature_id" "$branch" "$ws_path" "removed"

    echo ""
    echo -e "${GREEN}✓ Workspace removed for feature: $feature_id${NC}"
    echo ""
}

# ============================================================================
# FEATURE EXECUTION (Ralph Orchestrator)
# ============================================================================

# Find project root by looking for product-development/features directory
find_project_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/product-development/features" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    return 1
}

# Feature execution
cmd_build_feature() {
    local feature_id="$1"
    local max_iterations="$2"
    local start_time=$SECONDS

    if [[ -z "$feature_id" ]]; then
        echo -e "${RED}Error: Feature ID required${NC}"
        echo "Usage: pdm --build-feature <feature-id> [--max-iterations <n>]"
        exit 1
    fi

    # Find project root
    local project_root
    if ! project_root=$(find_project_root); then
        echo -e "${RED}Error: Could not find project with product-development/features directory${NC}"
        echo "Make sure you're running from within a project directory."
        exit 1
    fi

    # Workspace detection and auto-creation
    local using_workspace=false
    local effective_root="$project_root"
    local ws_path
    ws_path=$(get_workspace_path "$feature_id")

    if [[ -z "$ws_path" ]]; then
        # Validate feature exists on main before trying to create workspace
        local main_feature_dir="$project_root/product-development/features/$feature_id"
        local main_prd="$main_feature_dir/prd.json"
        if [[ ! -d "$main_feature_dir" ]]; then
            echo -e "${RED}Error: Feature directory not found: $main_feature_dir${NC}"
            exit 1
        fi
        if [[ ! -f "$main_prd" ]]; then
            echo -e "${RED}Error: prd.json not found: $main_prd${NC}"
            echo -e "${YELLOW}Run /pdm-create-prd-json $feature_id first to generate prd.json${NC}"
            exit 1
        fi

        echo -e "${YELLOW}No workspace found for '$feature_id'. Creating one...${NC}"
        cmd_create_workspace "$feature_id"
        ws_path=$(get_workspace_path "$feature_id")
    fi

    if [[ -n "$ws_path" ]]; then
        effective_root="$ws_path"
        using_workspace=true
        echo -e "${GREEN}✓ Using workspace: $ws_path${NC}"
    fi

    local features_dir="$effective_root/product-development/features"
    local feature_dir="$features_dir/$feature_id"
    local prd_json="$feature_dir/prd.json"
    local progress_file="$feature_dir/progress.txt"
    local last_branch_file="$feature_dir/.last-branch"
    local archive_dir="$feature_dir/archive"
    local project_learnings="$effective_root/LEARNINGS.md"

    # Validate feature directory
    if [[ ! -d "$feature_dir" ]]; then
        echo -e "${RED}Error: Feature directory not found: $feature_dir${NC}"
        exit 1
    fi

    # Validate prd.json
    if [[ ! -f "$prd_json" ]]; then
        echo -e "${RED}Error: prd.json not found: $prd_json${NC}"
        echo -e "${YELLOW}Run /pdm-create-prd-json $feature_id first to generate prd.json${NC}"
        exit 1
    fi

    # Check for required tools
    if ! command -v claude &> /dev/null; then
        echo -e "${RED}Error: Claude CLI not found${NC}"
        exit 1
    fi

    # Initialize progress file if needed
    if [[ ! -f "$progress_file" ]]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        cat > "$progress_file" << EOF
# Progress Log: $feature_id
# Started: $timestamp

## Codebase Patterns

[Patterns and learnings discovered during implementation will be recorded here]

---

## Story Progress

EOF
        echo -e "${GREEN}✓ Initialized progress.txt${NC}"
    fi

    # Initialize LEARNINGS.md if needed
    if [[ ! -f "$project_learnings" ]]; then
        cat > "$project_learnings" << 'HEADER'
# Project Learnings

Accumulated codebase patterns and insights discovered during feature implementations.
Each section represents learnings from a completed feature.

---

HEADER
        echo -e "${GREEN}✓ Initialized LEARNINGS.md${NC}"
    fi

    # Archive previous run if branch changed
    if [[ -f "$last_branch_file" && -f "$prd_json" ]]; then
        local last_branch=$(cat "$last_branch_file")
        local current_branch=$(json_get "$prd_json" ".branchName")

        if [[ -n "$last_branch" && "$last_branch" != "$current_branch" ]]; then
            if [[ -f "$progress_file" ]] && [[ $(wc -l < "$progress_file") -gt 10 ]]; then
                local archive_name=$(date '+%Y-%m-%d')-$(echo "$last_branch" | sed 's/.*\///')
                local archive_path="$archive_dir/$archive_name"

                mkdir -p "$archive_path"
                cp "$prd_json" "$archive_path/"
                cp "$progress_file" "$archive_path/"

                echo -e "${YELLOW}✓ Archived previous run to: $archive_path${NC}"

                rm "$progress_file"
                init_progress_file
            fi
        fi
    fi

    # Update last branch tracking
    local branch=$(json_get "$prd_json" ".branchName")
    if [[ -n "$branch" ]]; then
        echo "$branch" > "$last_branch_file"
    fi

    # Count stories
    local total_stories=$(json_array_length "$prd_json" ".userStories")
    local incomplete_count=$(node -e "
        const data = JSON.parse(require('fs').readFileSync('$prd_json', 'utf8'));
        console.log(data.userStories.filter(s => !s.passes).length);
    ")
    local complete_count=$((total_stories - incomplete_count))

    # Print status
    echo ""
    echo -e "${CYAN}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║  PDM Ralph Orchestrator - Feature: ${feature_id}${NC}"
    echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${CYAN}║  Stories: ${complete_count}/${total_stories} complete${NC}"
    echo -e "${CYAN}║  Elapsed: $(format_elapsed $((SECONDS - start_time)))${NC}"
    echo -e "${CYAN}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Check if already complete
    if [[ "$incomplete_count" -eq 0 ]]; then
        echo -e "${GREEN}✓ All stories already complete!${NC}"
        exit 0
    fi

    echo -e "${BLUE}Starting iteration loop (max: $max_iterations)${NC}"
    echo ""

    local first_story_done=false

    # Main loop
    for i in $(seq 1 $max_iterations); do
        # Get next incomplete story
        local next_story=$(node -e "
            const data = JSON.parse(require('fs').readFileSync('$prd_json', 'utf8'));
            const incomplete = data.userStories.filter(s => !s.passes).sort((a,b) => a.priority - b.priority);
            console.log(incomplete[0]?.id || '');
        ")

        if [[ -z "$next_story" ]]; then
            echo -e "${GREEN}✓ All stories complete!${NC}"
            exit 0
        fi

        # Get model for story
        local story_model=$(node -e "
            const data = JSON.parse(require('fs').readFileSync('$prd_json', 'utf8'));
            const story = data.userStories.find(s => s.id === '$next_story');
            console.log(story?.model || 'sonnet');
        ")

        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}  Iteration $i/$max_iterations - Working on: $next_story (model: $story_model)${NC}"
        echo -e "${CYAN}  Elapsed: $(format_elapsed $((SECONDS - start_time)))${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        # Determine if first story
        local is_first="false"
        if [[ "$first_story_done" == "false" ]]; then
            is_first="true"
            first_story_done=true
        fi

        # Build learnings instruction
        local learnings_instruction=""
        if [[ "$is_first" == "true" && -f "$project_learnings" ]]; then
            learnings_instruction="
IMPORTANT: This is the first story of this feature.
Read the project learnings file first: $project_learnings
Apply relevant patterns from previous features to this implementation.
"
        fi

        # Build workspace-specific instructions
        local branch_instruction="4. Checkout or create the branch specified in branchName"
        local workspace_context=""
        if [[ "$using_workspace" == "true" ]]; then
            branch_instruction="4. The feature branch is already checked out in this workspace. Do NOT run git checkout or git switch."
            workspace_context="
## Workspace Context

You are running inside an isolated git worktree workspace at: $effective_root
The feature branch is already checked out. Do NOT switch branches.
All file paths are relative to this workspace directory.
"
        fi

        # Build prompt
        local prompt="You are executing the PDM Ralph autonomous agent loop for feature: $feature_id
$learnings_instruction
IMPORTANT: Read and follow these instructions exactly.
$workspace_context
## Your Task This Iteration

1. Read the PRD file: $prd_json
2. Read the progress file: $progress_file (check Codebase Patterns section first)
3. Find the highest priority user story where \"passes\": false
$branch_instruction
5. Implement for ONLY that one user story.
6. Generate/Update unit tests (for this story) and newly added or updated UI components, hooks, libraries.
7. Run lint: npm run lint only for new UI components and their associated test scripts in this story.
8. Run quality checks npm run build.
9. Follow acceptance criteria exactly - only verify in browser if the story's criteria includes \"Verify in browser\"
10. If ALL checks pass:
   - Commit with message: \"feat: [Story ID] - [Story Title]\"
   - Update prd.json: set that story's \"passes\": true
   - Append to progress.txt with what you learned
11. If checks FAIL:
   - Do NOT commit
   - Fix the issues and retry
   - If you cannot fix after 3 attempts, update the story's \"notes\" field with the blocker

## Completion Signal

After updating prd.json, check if ALL stories have \"passes\": true.
If ALL stories pass, output this EXACT text on its own line:
<promise>COMPLETE</promise>

If stories remain incomplete, just finish this iteration normally.

## Quality Gates

- Typecheck must pass (npm run build)
- Lint must pass (npm run lint)
- UI stories must pass browser verification
- NO commits if checks fail

## File Locations

- PRD: $prd_json
- Progress: $progress_file
- Feature directory: $feature_dir

Begin now. Read the prd.json first to find the next story to implement."

        # Run Claude with model selection - stream to terminal and capture for parsing
        local output_file=$(mktemp)
        trap "rm -f '$output_file'" EXIT

        if [[ "$using_workspace" == "true" ]]; then
            (cd "$effective_root" && echo "$prompt" | claude --dangerously-skip-permissions --model "$story_model" --print 2>&1) | tee "$output_file" || true
        else
            echo "$prompt" | claude --dangerously-skip-permissions --model "$story_model" --print 2>&1 | tee "$output_file" || true
        fi

        local output=$(cat "$output_file")
        rm -f "$output_file"

        # Check for completion signal
        if echo "$output" | grep -q "<promise>COMPLETE</promise>"; then
            # Append learnings to project-level file
            local feature_name=$(json_get "$prd_json" ".featureName")
            local timestamp=$(date '+%Y-%m-%d')

            echo "" >> "$project_learnings"
            echo "## $feature_name ($timestamp)" >> "$project_learnings"
            echo "" >> "$project_learnings"

            sed -n '/^## Codebase Patterns$/,/^---$/p' "$progress_file" | \
                sed '1d;$d' >> "$project_learnings"

            echo "---" >> "$project_learnings"

            echo -e "${GREEN}✓ Appended learnings to LEARNINGS.md${NC}"

            echo ""
            echo -e "${GREEN}╔═══════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${GREEN}║                    ALL STORIES COMPLETE!                      ║${NC}"
            echo -e "${GREEN}║              Total time: $(format_elapsed $((SECONDS - start_time)))${NC}"
            echo -e "${GREEN}╚═══════════════════════════════════════════════════════════════╝${NC}"
            echo ""

            # Print final status
            total_stories=$(json_array_length "$prd_json" ".userStories")
            echo "Stories: $total_stories/$total_stories complete"

            if [[ "$using_workspace" == "true" ]]; then
                echo ""
                echo -e "${BLUE}Next step: Review the code, then run:${NC}"
                echo -e "  pdm --complete-feature $feature_id"
            fi
            exit 0
        fi

        # Print iteration summary
        incomplete_count=$(node -e "
            const data = JSON.parse(require('fs').readFileSync('$prd_json', 'utf8'));
            console.log(data.userStories.filter(s => !s.passes).length);
        ")
        complete_count=$((total_stories - incomplete_count))

        echo ""
        echo -e "${CYAN}║  Stories: ${complete_count}/${total_stories} complete | Elapsed: $(format_elapsed $((SECONDS - start_time)))${NC}"
        echo ""

        # Small delay between iterations
        sleep 2
    done

    # Max iterations reached
    echo ""
    echo -e "${YELLOW}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${YELLOW}║  Max iterations ($max_iterations) reached. Some stories incomplete.${NC}"
    echo -e "${YELLOW}║  Total time: $(format_elapsed $((SECONDS - start_time)))${NC}"
    echo -e "${YELLOW}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    echo -e "${YELLOW}Incomplete stories: $incomplete_count/$total_stories${NC}"
    echo -e "${YELLOW}Check $progress_file for details.${NC}"

    exit 1
}

# ============================================================================
# MAIN
# ============================================================================

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then

# Default values
MAX_ITERATIONS=10
FEATURE_ID=""
FEATURE_NAME=""
COMMAND=""
INSTALL_TYPE=""
FORCE_FLAG=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --install)
            COMMAND="install"
            if [[ -n "$2" && ! "$2" =~ ^-- ]]; then
                INSTALL_TYPE="$2"
                shift
            fi
            shift
            ;;
        --update)
            COMMAND="update"
            shift
            ;;
        --uninstall)
            COMMAND="uninstall"
            shift
            ;;
        --list)
            COMMAND="list"
            shift
            ;;
        --check)
            COMMAND="check"
            shift
            ;;
        --draft-feature)
            COMMAND="draft-feature"
            if [[ -n "$2" && ! "$2" =~ ^-- ]]; then
                FEATURE_NAME="$2"
                shift
            fi
            shift
            ;;
        --build-feature|-f)
            COMMAND="build-feature"
            FEATURE_ID="$2"
            shift 2
            ;;
        --create-workspace)
            COMMAND="create-workspace"
            FEATURE_ID="$2"
            shift 2
            ;;
        --list-workspaces)
            COMMAND="list-workspaces"
            shift
            ;;
        --complete-feature)
            COMMAND="complete-feature"
            FEATURE_ID="$2"
            shift 2
            ;;
        --cleanup-workspace)
            COMMAND="cleanup-workspace"
            FEATURE_ID="$2"
            if [[ -n "$3" && "$3" == "--force" ]]; then
                FORCE_FLAG="--force"
                shift
            fi
            shift 2
            ;;
        --max-iterations)
            MAX_ITERATIONS="$2"
            shift 2
            ;;
        --version|-v)
            echo "pdm version $VERSION"
            exit 0
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown option $1${NC}"
            usage
            exit 1
            ;;
    esac
done

# Execute command
case $COMMAND in
    install)
        cmd_install "$INSTALL_TYPE"
        ;;
    update)
        cmd_update
        ;;
    uninstall)
        cmd_uninstall
        ;;
    list)
        cmd_list
        ;;
    check)
        cmd_check
        ;;
    draft-feature)
        cmd_draft_feature "$FEATURE_NAME"
        ;;
    build-feature)
        cmd_build_feature "$FEATURE_ID" "$MAX_ITERATIONS"
        ;;
    create-workspace)
        cmd_create_workspace "$FEATURE_ID"
        ;;
    list-workspaces)
        cmd_list_workspaces
        ;;
    complete-feature)
        cmd_complete_feature "$FEATURE_ID"
        ;;
    cleanup-workspace)
        cmd_cleanup_workspace "$FEATURE_ID" "$FORCE_FLAG"
        ;;
    "")
        usage
        exit 0
        ;;
    *)
        echo -e "${RED}Error: Unknown command${NC}"
        usage
        exit 1
        ;;
esac

fi # end BASH_SOURCE guard
