#!/bin/bash

# PDM - Project Dev Manager
# Global CLI tool for autonomous feature development
# Installs skills and commands to ~/.claude/ with pdm- prefixes

set -e

VERSION="1.0.0"
CLAUDE_DIR="$HOME/.claude"
SKILLS_DIR="$CLAUDE_DIR/skills"
COMMANDS_DIR="$CLAUDE_DIR/commands"
PDM_REPO="dlee-mindcurv/pdm-tools"
RAW_BASE="https://raw.githubusercontent.com/$PDM_REPO/main"
ARCHIVE_URL="https://github.com/$PDM_REPO/archive/refs/heads/main.tar.gz"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Print usage
usage() {
    echo ""
    echo -e "${BLUE}PDM - Project Dev Manager${NC} v${VERSION}"
    echo ""
    echo "Usage: pdm <command> [options]"
    echo ""
    echo -e "${CYAN}Installation Commands:${NC}"
    echo "  --install [type]     Install skills and commands to ~/.claude/"
    echo "                       type: 'skills', 'commands', or omit for all"
    echo "  --update             Force re-download everything"
    echo "  --uninstall          Remove all pdm-* skills and commands"
    echo ""
    echo -e "${CYAN}Info Commands:${NC}"
    echo "  --list               Show installed pdm-* items"
    echo "  --check              Verify dependencies (Claude CLI, Node, Git, curl)"
    echo ""
    echo -e "${CYAN}Feature Lifecycle:${NC}"
    echo "  --draft-feature [name]     Create a new feature (interactive if no name given)"
    echo "  --build-feature, -f <id>   Run Ralph on feature"
    echo "  --max-iterations <n>  Max iterations for feature execution (default: 10)"
    echo ""
    echo -e "${CYAN}Meta:${NC}"
    echo "  --version, -v        Show version"
    echo "  --help, -h           Show this help message"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  pdm --install              # Install all skills and commands"
    echo "  pdm --install skills       # Install only skills"
    echo "  pdm --list                 # Show installed items"
    echo "  pdm --draft-feature                # Interactive feature creation"
    echo "  pdm --draft-feature \"Dark Mode\"    # Create feature with name directly"
    echo "  pdm -f my-feature          # Execute Ralph on 'my-feature' feature"
    echo "  pdm -f my-feature --max-iterations 20"
    echo ""
}

# JSON helper using Node.js (eliminates jq dependency)
json_get() {
    local file="$1"
    local path="$2"
    node -e "console.log(JSON.parse(require('fs').readFileSync('$file','utf8'))$path || '')" 2>/dev/null
}

json_array_length() {
    local file="$1"
    local path="$2"
    node -e "console.log(JSON.parse(require('fs').readFileSync('$file','utf8'))$path.length)" 2>/dev/null
}

json_array_item() {
    local file="$1"
    local path="$2"
    local index="$3"
    local prop="$4"
    node -e "console.log(JSON.parse(require('fs').readFileSync('$file','utf8'))$path[$index].$prop || '')" 2>/dev/null
}

# Generate feature ID from name (e.g., "My Feature" -> "my-feature")
generate_feature_id() {
    local name="$1"
    echo "$name" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-'
}

# Update status.json with a new feature entry (uses Node.js, no jq dependency)
update_status_json() {
    local status_file="$1"
    local id="$2"
    local name="$3"
    local status="${4:-OPEN}"
    local timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')

    # Create status.json if it doesn't exist
    if [[ ! -f "$status_file" ]]; then
        echo '{ "features": [] }' > "$status_file"
    fi

    node -e "
        const fs = require('fs');
        const file = process.argv[1];
        const id = process.argv[2];
        const name = process.argv[3];
        const status = process.argv[4];
        const ts = process.argv[5];
        const data = JSON.parse(fs.readFileSync(file, 'utf8'));
        if (data.features.some(f => f.id === id)) {
            console.log('Feature ' + id + ' already exists in status.json');
            process.exit(0);
        }
        data.features.push({ id, name, status, createdAt: ts, updatedAt: ts });
        fs.writeFileSync(file, JSON.stringify(data, null, 2) + '\n');
    " "$status_file" "$id" "$name" "$status" "$timestamp"
}

format_elapsed() {
    local total_seconds="$1"
    local hours=$((total_seconds / 3600))
    local minutes=$(( (total_seconds % 3600) / 60 ))
    local seconds=$((total_seconds % 60))
    if [[ $hours -gt 0 ]]; then
        printf "%dh %dm %ds" "$hours" "$minutes" "$seconds"
    elif [[ $minutes -gt 0 ]]; then
        printf "%dm %ds" "$minutes" "$seconds"
    else
        printf "%ds" "$seconds"
    fi
}

# Create JTBD template if it doesn't exist
setup_jtbd_template() {
    local resources_dir="$1"
    local template_file="$resources_dir/JTBD-template.md"

    mkdir -p "$resources_dir"

    if [[ -f "$template_file" ]]; then
        return 0
    fi

    cat > "$template_file" << 'JTBD_EOF'
# Jobs-to-be-Done Analysis: [FEATURE_NAME]

## Feature Summary

[Brief description of the feature]

---

## Job Statements

### Primary Job

**When** [situation], **I want** [motivation], **so I can** [expected outcome].

### Secondary Jobs

1. **When** [situation], **I want** [motivation], **so I can** [expected outcome].

---

## User Needs and Pain Points

### Needs

| Need | Description |
|------|-------------|
| [Need] | [Description] |

### Pain Points Addressed

| Pain Point | How This Feature Helps |
|------------|----------------------|
| [Pain Point] | [How it helps] |

---

## Desired Outcomes (User Perspective)

### Functional Outcomes

- [Outcome]

### Emotional Outcomes

- [Outcome]

### Social Outcomes

- [Outcome]

---

## Competitive Analysis (JTBD Lens)

| Competitor | How They Solve This Job |
|------------|------------------------|
| [Competitor] | [Their approach] |

### Competitive Insight

[Analysis of competitive landscape]

---

## Market Opportunity Assessment

### Brand Differentiation

- [Differentiation point]

### User Expectations

[What users expect]

### Strategic Value

| Factor | Impact |
|--------|--------|
| [Factor] | [Impact] |

---

## Success Criteria (From User Perspective)

- [Success criterion]

---

## Assumptions to Validate

1. [Assumption to validate]
JTBD_EOF
    echo -e "${GREEN}✓ Created JTBD template: $template_file${NC}"
}

# Create PRD template if it doesn't exist
setup_prd_template() {
    local resources_dir="$1"
    local template_file="$resources_dir/PRD-template.md"

    mkdir -p "$resources_dir"

    if [[ -f "$template_file" ]]; then
        return 0
    fi

    cat > "$template_file" << 'PRD_EOF'
# PRD: [FEATURE_NAME]

## Introduction

[Brief description of the feature and the problem it solves.]

## Goals

- [Specific, measurable objective]
- [Another objective]

## User Stories

### US-001: [Title]
**Description:** As a [user], I want [feature] so that [benefit].

**Acceptance Criteria:**
- [ ] Specific verifiable criterion
- [ ] Another criterion
- [ ] Typecheck/lint passes

### US-002: [Title]
**Description:** As a [user], I want [feature] so that [benefit].

**Acceptance Criteria:**
- [ ] Specific verifiable criterion
- [ ] Typecheck/lint passes
- [ ] Verify in browser using dev-browser skill

## Functional Requirements

- FR-1: The system must [specific functionality]
- FR-2: When a user [action], the system must [response]

## Non-Goals

- [What this feature will NOT include]
- [Another exclusion]

## Design Considerations

- [UI/UX requirements]
- [Relevant existing components to reuse]

## Technical Considerations

- [Known constraints or dependencies]
- [Integration points with existing systems]

## Success Metrics

- [How success will be measured]
- [Another metric]

## Open Questions

- [Remaining questions or areas needing clarification]
PRD_EOF
    echo -e "${GREEN}✓ Created PRD template: $template_file${NC}"
}

# Check dependencies
cmd_check() {
    echo ""
    echo -e "${BLUE}Checking PDM dependencies...${NC}"
    echo ""

    local all_ok=true

    # Claude CLI
    if command -v claude &> /dev/null; then
        local claude_version=$(claude --version 2>&1 | head -1 || echo "unknown")
        echo -e "${GREEN}✓${NC} Claude CLI: $claude_version"
    else
        echo -e "${RED}✗${NC} Claude CLI: not found"
        echo "  Install from: https://github.com/anthropics/claude-code"
        all_ok=false
    fi

    # Node.js
    if command -v node &> /dev/null; then
        local node_version=$(node --version)
        echo -e "${GREEN}✓${NC} Node.js: $node_version"

        # Check version >= 18
        local major_version=$(echo "$node_version" | sed 's/v//' | cut -d. -f1)
        if [[ "$major_version" -lt 18 ]]; then
            echo -e "  ${YELLOW}Warning: Node.js 18+ recommended${NC}"
        fi
    else
        echo -e "${RED}✗${NC} Node.js: not found"
        all_ok=false
    fi

    # Git
    if command -v git &> /dev/null; then
        local git_version=$(git --version | sed 's/git version //')
        echo -e "${GREEN}✓${NC} Git: $git_version"
    else
        echo -e "${RED}✗${NC} Git: not found"
        all_ok=false
    fi

    # curl
    if command -v curl &> /dev/null; then
        local curl_version=$(curl --version | head -1 | awk '{print $2}')
        echo -e "${GREEN}✓${NC} curl: $curl_version"
    else
        echo -e "${RED}✗${NC} curl: not found"
        all_ok=false
    fi

    # Bash
    echo -e "${GREEN}✓${NC} Bash: $BASH_VERSION"

    echo ""
    if $all_ok; then
        echo -e "${GREEN}All dependencies satisfied!${NC}"
    else
        echo -e "${RED}Some dependencies are missing. Please install them.${NC}"
        exit 1
    fi
}

# List installed pdm-* items
cmd_list() {
    echo ""
    echo -e "${BLUE}Installed PDM items${NC}"
    echo ""

    echo -e "${CYAN}Skills:${NC} ($SKILLS_DIR)"
    if [[ -d "$SKILLS_DIR" ]]; then
        local skills=$(ls -1 "$SKILLS_DIR" 2>/dev/null | grep "^pdm-" || true)
        if [[ -n "$skills" ]]; then
            echo "$skills" | while read skill; do
                echo "  • $skill"
            done
        else
            echo "  (none)"
        fi
    else
        echo "  (directory does not exist)"
    fi

    echo ""
    echo -e "${CYAN}Commands:${NC} ($COMMANDS_DIR)"
    if [[ -d "$COMMANDS_DIR" ]]; then
        local commands=$(ls -1 "$COMMANDS_DIR" 2>/dev/null | grep "^pdm-" || true)
        if [[ -n "$commands" ]]; then
            echo "$commands" | while read cmd; do
                echo "  • /${cmd%.md}"
            done
        else
            echo "  (none)"
        fi
    else
        echo "  (directory does not exist)"
    fi
    echo ""
}

# Install skills and/or commands
cmd_install() {
    local install_type="${1:-all}"  # skills, commands, or all

    echo ""
    echo -e "${BLUE}Installing PDM tools to $CLAUDE_DIR...${NC}"
    echo ""

    # Create directories
    mkdir -p "$SKILLS_DIR" "$COMMANDS_DIR"

    # Create temp directory for download
    local tmp_dir=$(mktemp -d)
    local archive_file="$tmp_dir/pdm-tools.tar.gz"
    local extract_dir="$tmp_dir/extracted"

    # Download archive
    echo -e "${CYAN}Downloading from $PDM_REPO...${NC}"
    if ! curl -sL "$ARCHIVE_URL" -o "$archive_file"; then
        echo -e "${RED}Error: Failed to download from GitHub${NC}"
        rm -rf "$tmp_dir"
        exit 1
    fi

    # Extract archive
    mkdir -p "$extract_dir"
    tar -xzf "$archive_file" -C "$extract_dir"

    # Find extracted directory (usually pdm-tools-main)
    local src_dir=$(find "$extract_dir" -maxdepth 1 -type d -name "pdm-tools-*" | head -1)

    if [[ -z "$src_dir" || ! -d "$src_dir" ]]; then
        echo -e "${RED}Error: Could not find extracted content${NC}"
        rm -rf "$tmp_dir"
        exit 1
    fi

    # Install skills
    if [[ "$install_type" == "all" || "$install_type" == "skills" ]]; then
        if [[ -d "$src_dir/skills" ]]; then
            echo ""
            echo -e "${CYAN}Installing skills...${NC}"
            for skill_dir in "$src_dir/skills"/pdm-*; do
                if [[ -d "$skill_dir" ]]; then
                    local skill_name=$(basename "$skill_dir")
                    echo "  • $skill_name"
                    rm -rf "$SKILLS_DIR/$skill_name"
                    cp -r "$skill_dir" "$SKILLS_DIR/"
                fi
            done
        else
            echo -e "${YELLOW}No skills directory found in repository${NC}"
        fi
    fi

    # Install commands
    if [[ "$install_type" == "all" || "$install_type" == "commands" ]]; then
        if [[ -d "$src_dir/commands" ]]; then
            echo ""
            echo -e "${CYAN}Installing commands...${NC}"
            for cmd_file in "$src_dir/commands"/pdm-*.md; do
                if [[ -f "$cmd_file" ]]; then
                    local cmd_name=$(basename "$cmd_file")
                    echo "  • /${cmd_name%.md}"
                    cp "$cmd_file" "$COMMANDS_DIR/"
                fi
            done
        else
            echo -e "${YELLOW}No commands directory found in repository${NC}"
        fi
    fi

    # Cleanup
    rm -rf "$tmp_dir"

    echo ""
    echo -e "${GREEN}✓ Installation complete!${NC}"
    echo ""
    echo "Run 'pdm --list' to see installed items."
    echo ""
}

# Update (force re-download)
cmd_update() {
    echo -e "${BLUE}Updating PDM tools...${NC}"
    cmd_uninstall
    cmd_install all
}

# Uninstall pdm-* items
cmd_uninstall() {
    echo ""
    echo -e "${BLUE}Removing PDM skills and commands...${NC}"
    echo ""

    # Remove skills
    if [[ -d "$SKILLS_DIR" ]]; then
        local skills=$(ls -1 "$SKILLS_DIR" 2>/dev/null | grep "^pdm-" || true)
        if [[ -n "$skills" ]]; then
            echo -e "${CYAN}Removing skills:${NC}"
            echo "$skills" | while read skill; do
                echo "  • $skill"
                rm -rf "$SKILLS_DIR/$skill"
            done
        fi
    fi

    # Remove commands
    if [[ -d "$COMMANDS_DIR" ]]; then
        local commands=$(ls -1 "$COMMANDS_DIR" 2>/dev/null | grep "^pdm-" || true)
        if [[ -n "$commands" ]]; then
            echo -e "${CYAN}Removing commands:${NC}"
            echo "$commands" | while read cmd; do
                echo "  • $cmd"
                rm -f "$COMMANDS_DIR/$cmd"
            done
        fi
    fi

    echo ""
    echo -e "${GREEN}✓ Uninstall complete!${NC}"
    echo ""
}

# ============================================================================
# FEATURE CREATION
# ============================================================================

# Create a new feature (interactive or direct)
cmd_draft_feature() {
    local feature_name="$1"

    echo ""
    echo -e "${BLUE}╔═══════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║     Feature Creation                  ║${NC}"
    echo -e "${BLUE}╚═══════════════════════════════════════╝${NC}"
    echo ""

    # Find project root (or use current directory)
    local project_root
    if project_root=$(find_project_root); then
        echo -e "${GREEN}✓ Found project root: $project_root${NC}"
    else
        project_root="$PWD"
        echo -e "${YELLOW}No existing product-development directory found.${NC}"
        echo -e "${YELLOW}Using current directory: $project_root${NC}"
    fi

    local features_dir="$project_root/product-development/features"
    local resources_dir="$project_root/product-development/resources"
    local status_json="$features_dir/status.json"
    local product_md="$project_root/product.md"

    # Create directories
    mkdir -p "$features_dir" "$resources_dir"

    # Copy product.md to resources if it exists
    if [[ -f "$product_md" ]]; then
        cp "$product_md" "$resources_dir/product.md"
        echo -e "${GREEN}✓ Copied product.md to resources directory${NC}"
    fi

    # Setup templates
    setup_jtbd_template "$resources_dir"
    setup_prd_template "$resources_dir"

    # Check for Claude CLI
    if ! command -v claude &> /dev/null; then
        echo -e "${RED}Error: Claude CLI not found.${NC}"
        echo -e "Please install Claude Code and try again."
        exit 1
    fi

    # Ensure PDM skills are installed
    local command_file="$HOME/.claude/commands/pdm-create-jtbd.md"
    if [[ -f "$command_file" ]]; then
        echo -e "${GREEN}✓ PDM skills already installed${NC}"
    else
        echo -e "${YELLOW}PDM skills not found. Installing via pdm --install...${NC}"
        cmd_install
    fi

    echo ""

    # Feature ID will be set during input collection
    local feature_id=""

    if [[ -n "$feature_name" ]]; then
        # Direct mode: name provided via flag
        feature_id=$(generate_feature_id "$feature_name")
        echo -e "${BLUE}Feature name: $feature_name${NC}"
        echo -e "${BLUE}Generated feature ID: $feature_id${NC}"

        echo ""
        echo "Feature description (press Enter twice when done):"
        echo ""

        local feature_description=""
        while IFS= read -r line; do
            [[ -z "$line" ]] && break
            feature_description+="$line"$'\n'
        done
        feature_description="${feature_description%$'\n'}"

        if [[ -z "$feature_description" ]]; then
            echo -e "${RED}Error: Feature description cannot be empty${NC}"
            exit 1
        fi

        # Create feature directory and file
        local feature_dir="$features_dir/$feature_id"
        mkdir -p "$feature_dir"
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        cat > "$feature_dir/feature.md" << FEAT_EOF
# Feature: $feature_name

## Description

$feature_description

## Status

- Created: $timestamp
- Status: Draft
FEAT_EOF

        echo -e "${GREEN}✓ Created feature file: $feature_dir/feature.md${NC}"
        update_status_json "$status_json" "$feature_id" "$feature_name" "OPEN"
        echo -e "${GREEN}✓ Updated status.json with feature: $feature_id${NC}"

    else
        # Interactive mode: show menu
        echo -e "${YELLOW}Create a new feature:${NC}"
        echo ""
        echo -e "${BLUE}How would you like to provide the feature details?${NC}"
        echo ""
        echo "  1) Enter feature name and description manually"
        echo "  2) Reference an existing feature file"
        echo "  3) Cancel"
        echo ""
        read -p "Select an option [1-3]: " choice

        case $choice in
            1)
                echo ""
                echo -e "${BLUE}Enter feature details:${NC}"
                echo ""

                read -p "Feature name: " feature_name
                if [[ -z "$feature_name" ]]; then
                    echo -e "${RED}Error: Feature name cannot be empty${NC}"
                    exit 1
                fi

                feature_id=$(generate_feature_id "$feature_name")
                echo -e "${BLUE}Generated feature ID: $feature_id${NC}"

                echo ""
                echo "Feature description (press Enter twice when done):"
                echo ""

                local feature_description=""
                while IFS= read -r line; do
                    [[ -z "$line" ]] && break
                    feature_description+="$line"$'\n'
                done
                feature_description="${feature_description%$'\n'}"

                if [[ -z "$feature_description" ]]; then
                    echo -e "${RED}Error: Feature description cannot be empty${NC}"
                    exit 1
                fi

                # Create feature directory and file
                local feature_dir="$features_dir/$feature_id"
                mkdir -p "$feature_dir"
                local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
                cat > "$feature_dir/feature.md" << FEAT_EOF
# Feature: $feature_name

## Description

$feature_description

## Status

- Created: $timestamp
- Status: Draft
FEAT_EOF

                echo ""
                echo -e "${GREEN}✓ Created feature file: $feature_dir/feature.md${NC}"
                update_status_json "$status_json" "$feature_id" "$feature_name" "OPEN"
                echo -e "${GREEN}✓ Updated status.json with feature: $feature_id${NC}"
                ;;
            2)
                echo ""
                read -p "Enter the path to the existing feature file: " file_path
                file_path="${file_path/#\~/$HOME}"

                if [[ ! -f "$file_path" ]]; then
                    echo -e "${RED}Error: File not found: $file_path${NC}"
                    exit 1
                fi

                echo ""
                read -p "Enter a name for this feature (used to generate ID): " feature_name
                if [[ -z "$feature_name" ]]; then
                    echo -e "${RED}Error: Feature name cannot be empty${NC}"
                    exit 1
                fi

                feature_id=$(generate_feature_id "$feature_name")
                local feature_dir="$features_dir/$feature_id"
                mkdir -p "$feature_dir"
                cp "$file_path" "$feature_dir/feature.md"
                echo -e "${GREEN}✓ Copied feature file to: $feature_dir/feature.md${NC}"
                update_status_json "$status_json" "$feature_id" "$feature_name" "OPEN"
                echo -e "${GREEN}✓ Updated status.json with feature: $feature_id${NC}"
                ;;
            3)
                echo -e "${YELLOW}Cancelled.${NC}"
                exit 0
                ;;
            *)
                echo -e "${RED}Invalid option. Exiting.${NC}"
                exit 1
                ;;
        esac
    fi

    echo ""
    echo -e "${BLUE}Launching Claude Code with /pdm-create-jtbd ${feature_id}...${NC}"
    echo ""

    cd "$project_root"
    claude "/pdm-create-jtbd ${feature_id}"
}

# ============================================================================
# FEATURE EXECUTION (Ralph Orchestrator)
# ============================================================================

# Find project root by looking for product-development/features directory
find_project_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -d "$dir/product-development/features" ]]; then
            echo "$dir"
            return 0
        fi
        dir=$(dirname "$dir")
    done
    return 1
}

# Feature execution
cmd_build_feature() {
    local feature_id="$1"
    local max_iterations="$2"
    local start_time=$SECONDS

    if [[ -z "$feature_id" ]]; then
        echo -e "${RED}Error: Feature ID required${NC}"
        echo "Usage: pdm --build-feature <feature-id> [--max-iterations <n>]"
        exit 1
    fi

    # Find project root
    local project_root
    if ! project_root=$(find_project_root); then
        echo -e "${RED}Error: Could not find project with product-development/features directory${NC}"
        echo "Make sure you're running from within a project directory."
        exit 1
    fi

    local features_dir="$project_root/product-development/features"
    local feature_dir="$features_dir/$feature_id"
    local prd_json="$feature_dir/prd.json"
    local progress_file="$feature_dir/progress.txt"
    local last_branch_file="$feature_dir/.last-branch"
    local archive_dir="$feature_dir/archive"
    local project_learnings="$project_root/LEARNINGS.md"

    # Validate feature directory
    if [[ ! -d "$feature_dir" ]]; then
        echo -e "${RED}Error: Feature directory not found: $feature_dir${NC}"
        exit 1
    fi

    # Validate prd.json
    if [[ ! -f "$prd_json" ]]; then
        echo -e "${RED}Error: prd.json not found: $prd_json${NC}"
        echo -e "${YELLOW}Run /pdm-create-prd-json $feature_id first to generate prd.json${NC}"
        exit 1
    fi

    # Check for required tools
    if ! command -v claude &> /dev/null; then
        echo -e "${RED}Error: Claude CLI not found${NC}"
        exit 1
    fi

    # Initialize progress file if needed
    if [[ ! -f "$progress_file" ]]; then
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        cat > "$progress_file" << EOF
# Progress Log: $feature_id
# Started: $timestamp

## Codebase Patterns

[Patterns and learnings discovered during implementation will be recorded here]

---

## Story Progress

EOF
        echo -e "${GREEN}✓ Initialized progress.txt${NC}"
    fi

    # Initialize LEARNINGS.md if needed
    if [[ ! -f "$project_learnings" ]]; then
        cat > "$project_learnings" << 'HEADER'
# Project Learnings

Accumulated codebase patterns and insights discovered during feature implementations.
Each section represents learnings from a completed feature.

---

HEADER
        echo -e "${GREEN}✓ Initialized LEARNINGS.md${NC}"
    fi

    # Archive previous run if branch changed
    if [[ -f "$last_branch_file" && -f "$prd_json" ]]; then
        local last_branch=$(cat "$last_branch_file")
        local current_branch=$(json_get "$prd_json" ".branchName")

        if [[ -n "$last_branch" && "$last_branch" != "$current_branch" ]]; then
            if [[ -f "$progress_file" ]] && [[ $(wc -l < "$progress_file") -gt 10 ]]; then
                local archive_name=$(date '+%Y-%m-%d')-$(echo "$last_branch" | sed 's/.*\///')
                local archive_path="$archive_dir/$archive_name"

                mkdir -p "$archive_path"
                cp "$prd_json" "$archive_path/"
                cp "$progress_file" "$archive_path/"

                echo -e "${YELLOW}✓ Archived previous run to: $archive_path${NC}"

                rm "$progress_file"
                init_progress_file
            fi
        fi
    fi

    # Update last branch tracking
    local branch=$(json_get "$prd_json" ".branchName")
    if [[ -n "$branch" ]]; then
        echo "$branch" > "$last_branch_file"
    fi

    # Count stories
    local total_stories=$(json_array_length "$prd_json" ".userStories")
    local incomplete_count=$(node -e "
        const data = JSON.parse(require('fs').readFileSync('$prd_json', 'utf8'));
        console.log(data.userStories.filter(s => !s.passes).length);
    ")
    local complete_count=$((total_stories - incomplete_count))

    # Print status
    echo ""
    echo -e "${CYAN}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║  PDM Ralph Orchestrator - Feature: ${feature_id}${NC}"
    echo -e "${CYAN}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${CYAN}║  Stories: ${complete_count}/${total_stories} complete${NC}"
    echo -e "${CYAN}║  Elapsed: $(format_elapsed $((SECONDS - start_time)))${NC}"
    echo -e "${CYAN}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Check if already complete
    if [[ "$incomplete_count" -eq 0 ]]; then
        echo -e "${GREEN}✓ All stories already complete!${NC}"
        exit 0
    fi

    echo -e "${BLUE}Starting iteration loop (max: $max_iterations)${NC}"
    echo ""

    local first_story_done=false

    # Main loop
    for i in $(seq 1 $max_iterations); do
        # Get next incomplete story
        local next_story=$(node -e "
            const data = JSON.parse(require('fs').readFileSync('$prd_json', 'utf8'));
            const incomplete = data.userStories.filter(s => !s.passes).sort((a,b) => a.priority - b.priority);
            console.log(incomplete[0]?.id || '');
        ")

        if [[ -z "$next_story" ]]; then
            echo -e "${GREEN}✓ All stories complete!${NC}"
            exit 0
        fi

        # Get model for story
        local story_model=$(node -e "
            const data = JSON.parse(require('fs').readFileSync('$prd_json', 'utf8'));
            const story = data.userStories.find(s => s.id === '$next_story');
            console.log(story?.model || 'sonnet');
        ")

        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "${CYAN}  Iteration $i/$max_iterations - Working on: $next_story (model: $story_model)${NC}"
        echo -e "${CYAN}  Elapsed: $(format_elapsed $((SECONDS - start_time)))${NC}"
        echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""

        # Determine if first story
        local is_first="false"
        if [[ "$first_story_done" == "false" ]]; then
            is_first="true"
            first_story_done=true
        fi

        # Build learnings instruction
        local learnings_instruction=""
        if [[ "$is_first" == "true" && -f "$project_learnings" ]]; then
            learnings_instruction="
IMPORTANT: This is the first story of this feature.
Read the project learnings file first: $project_learnings
Apply relevant patterns from previous features to this implementation.
"
        fi

        # Build prompt
        local prompt="You are executing the PDM Ralph autonomous agent loop for feature: $feature_id
$learnings_instruction
IMPORTANT: Read and follow these instructions exactly.

## Your Task This Iteration

1. Read the PRD file: $prd_json
2. Read the progress file: $progress_file (check Codebase Patterns section first)
3. Find the highest priority user story where \"passes\": false
4. Checkout or create the branch specified in branchName
5. Implement ONLY that one user story
6. Run quality checks npm run build. Only run npm run lint if it is the LAST or ONLY story in the feature
7. Follow acceptance criteria exactly - only verify in browser if the story's criteria includes \"Verify in browser\"
8. If ALL checks pass:
   - Commit with message: \"feat: [Story ID] - [Story Title]\"
   - Update prd.json: set that story's \"passes\": true
   - Append to progress.txt with what you learned
9. If checks FAIL:
   - Do NOT commit
   - Fix the issues and retry
   - If you cannot fix after 3 attempts, update the story's \"notes\" field with the blocker

## Completion Signal

After updating prd.json, check if ALL stories have \"passes\": true.
If ALL stories pass, output this EXACT text on its own line:
<promise>COMPLETE</promise>

If stories remain incomplete, just finish this iteration normally.

## Quality Gates

- Typecheck must pass (npm run build)
- Lint must pass (npm run lint)
- UI stories must pass browser verification
- NO commits if checks fail

## File Locations

- PRD: $prd_json
- Progress: $progress_file
- Feature directory: $feature_dir

Begin now. Read the prd.json first to find the next story to implement."

        # Run Claude with model selection
        local output
        output=$(echo "$prompt" | claude --dangerously-skip-permissions --model "$story_model" --print 2>&1) || true

        # Check for completion signal
        if echo "$output" | grep -q "<promise>COMPLETE</promise>"; then
            # Append learnings to project-level file
            local feature_name=$(json_get "$prd_json" ".featureName")
            local timestamp=$(date '+%Y-%m-%d')

            echo "" >> "$project_learnings"
            echo "## $feature_name ($timestamp)" >> "$project_learnings"
            echo "" >> "$project_learnings"

            sed -n '/^## Codebase Patterns$/,/^---$/p' "$progress_file" | \
                sed '1d;$d' >> "$project_learnings"

            echo "---" >> "$project_learnings"

            echo -e "${GREEN}✓ Appended learnings to LEARNINGS.md${NC}"

            echo ""
            echo -e "${GREEN}╔═══════════════════════════════════════════════════════════════╗${NC}"
            echo -e "${GREEN}║                    ALL STORIES COMPLETE!                      ║${NC}"
            echo -e "${GREEN}║              Total time: $(format_elapsed $((SECONDS - start_time)))${NC}"
            echo -e "${GREEN}╚═══════════════════════════════════════════════════════════════╝${NC}"
            echo ""

            # Print final status
            total_stories=$(json_array_length "$prd_json" ".userStories")
            echo "Stories: $total_stories/$total_stories complete"
            exit 0
        fi

        # Print iteration summary
        incomplete_count=$(node -e "
            const data = JSON.parse(require('fs').readFileSync('$prd_json', 'utf8'));
            console.log(data.userStories.filter(s => !s.passes).length);
        ")
        complete_count=$((total_stories - incomplete_count))

        echo ""
        echo -e "${CYAN}║  Stories: ${complete_count}/${total_stories} complete | Elapsed: $(format_elapsed $((SECONDS - start_time)))${NC}"
        echo ""

        # Small delay between iterations
        sleep 2
    done

    # Max iterations reached
    echo ""
    echo -e "${YELLOW}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${YELLOW}║  Max iterations ($max_iterations) reached. Some stories incomplete.${NC}"
    echo -e "${YELLOW}║  Total time: $(format_elapsed $((SECONDS - start_time)))${NC}"
    echo -e "${YELLOW}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    echo -e "${YELLOW}Incomplete stories: $incomplete_count/$total_stories${NC}"
    echo -e "${YELLOW}Check $progress_file for details.${NC}"

    exit 1
}

# ============================================================================
# MAIN
# ============================================================================

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then

# Default values
MAX_ITERATIONS=10
FEATURE_ID=""
FEATURE_NAME=""
COMMAND=""
INSTALL_TYPE=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --install)
            COMMAND="install"
            if [[ -n "$2" && ! "$2" =~ ^-- ]]; then
                INSTALL_TYPE="$2"
                shift
            fi
            shift
            ;;
        --update)
            COMMAND="update"
            shift
            ;;
        --uninstall)
            COMMAND="uninstall"
            shift
            ;;
        --list)
            COMMAND="list"
            shift
            ;;
        --check)
            COMMAND="check"
            shift
            ;;
        --draft-feature)
            COMMAND="draft-feature"
            if [[ -n "$2" && ! "$2" =~ ^-- ]]; then
                FEATURE_NAME="$2"
                shift
            fi
            shift
            ;;
        --build-feature|-f)
            COMMAND="build-feature"
            FEATURE_ID="$2"
            shift 2
            ;;
        --max-iterations)
            MAX_ITERATIONS="$2"
            shift 2
            ;;
        --version|-v)
            echo "pdm version $VERSION"
            exit 0
            ;;
        --help|-h)
            usage
            exit 0
            ;;
        *)
            echo -e "${RED}Error: Unknown option $1${NC}"
            usage
            exit 1
            ;;
    esac
done

# Execute command
case $COMMAND in
    install)
        cmd_install "$INSTALL_TYPE"
        ;;
    update)
        cmd_update
        ;;
    uninstall)
        cmd_uninstall
        ;;
    list)
        cmd_list
        ;;
    check)
        cmd_check
        ;;
    draft-feature)
        cmd_draft_feature "$FEATURE_NAME"
        ;;
    build-feature)
        cmd_build_feature "$FEATURE_ID" "$MAX_ITERATIONS"
        ;;
    "")
        usage
        exit 0
        ;;
    *)
        echo -e "${RED}Error: Unknown command${NC}"
        usage
        exit 1
        ;;
esac

fi # end BASH_SOURCE guard
